struct material { vec3 materialAmbientColor; float materialAmbientFactor; vec3 materialDiffuseColor; float materialDiffuseFactor; vec3 materialSpecularColor; float materialSpecularFactor; float materialSpecularShininess; };

struct surface { float surfaceDistance; material surfaceMaterial; };

struct pointlight { vec3 pointlightTransformPosition; vec3 pointlightEmissionAmbientColor; float pointlightEmissionAmbientFactor; vec3 pointlightEmissionDiffuseColor; float pointlightEmissionDiffuseFactor; vec3 pointlightEmissionSpecularColor; float pointlightEmissionSpecularFactor; float pointlightEmissionMaximumDistance; };

struct spotlight
{
    vec3 spotlightTransformPosition;

    vec3 spotlightTransformDirection; // dirección del cono (NORMALIZADA)

    float spotlightInnerCutoff; // cos(innerAngle)
    float spotlightOuterCutoff; // cos(outerAngle)

    vec3 spotlightEmissionAmbientColor;
    float spotlightEmissionAmbientFactor;

    vec3 spotlightEmissionDiffuseColor;
    float spotlightEmissionDiffuseFactor;

    vec3 spotlightEmissionSpecularColor;
    float spotlightEmissionSpecularFactor;

    float spotlightEmissionMaximumDistance;
};

const vec3 CameraSettingsFocusPoint = vec3(0.0f, 0.0f, 0.0f).xyz;

mat3 getTransformEulerOrientation(const in vec3 transformTargetRotation)
{
    vec3 transformSineRotation = sin(radians(transformTargetRotation.xyz).xyz).xyz;
    
    vec3 transformCosineRotation = cos(radians(transformTargetRotation.xyz).xyz).xyz;
    
    mat3 transformPitchOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformPitchOrientation[0u].xyz = vec3(1.0f, 0.0f, 0.0f).xyz;
    transformPitchOrientation[1u].xyz = vec3(0.0f, transformCosineRotation.x, -transformSineRotation.x).xyz;
    transformPitchOrientation[2u].xyz = vec3(0.0f, transformSineRotation.x, transformCosineRotation.x).xyz;
    
    mat3 transformYawOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformYawOrientation[0u].xyz = vec3(transformCosineRotation.y, 0.0f, transformSineRotation.y).xyz;
    transformYawOrientation[1u].xyz = vec3(0.0f, 1.0f, 0.0f).xyz;
    transformYawOrientation[2u].xyz = vec3(-transformSineRotation.y, 0.0f, transformCosineRotation.y).xyz;
    
    mat3 transformRollOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformRollOrientation[0u].xyz = vec3(transformCosineRotation.z, -transformSineRotation.z, 0.0f).xyz;
    transformRollOrientation[1u].xyz = vec3(transformSineRotation.z, transformCosineRotation.z, 0.0f).xyz;
    transformRollOrientation[2u].xyz = vec3(0.0f, 0.0f, 1.0f).xyz;
    
    mat3 transformEulerOrientation = transformPitchOrientation * transformYawOrientation * transformRollOrientation;
    
    return transformEulerOrientation;
}

mat3 getTransformLookAtOrientation(const in vec3 transformOriginPosition, const in vec3 transformTargetPosition)
{
    vec3 transformForwardDirection = normalize(transformTargetPosition.xyz - transformOriginPosition.xyz).xyz;
    
    vec3 transformRightwardDirection = normalize(cross(vec3(0.0f, 1.0f, 0.0f).xyz, transformForwardDirection.xyz).xyz).xyz;
    
    vec3 transformUpwardDirection = normalize(cross(transformForwardDirection.xyz, transformRightwardDirection.xyz).xyz).xyz;
    
    mat3 transformLookAtOrientation = mat3(-transformRightwardDirection.xyz, transformUpwardDirection.xyz, -transformForwardDirection.xyz);
    
    return transformLookAtOrientation;
}

surface getMixedSurface(const in surface firstSurface, const in surface secondSurface, const in float mixedSurfaceSmoothness)
{
    float surfaceDistanceFactor = clamp(0.5f + 0.5f * (firstSurface.surfaceDistance - secondSurface.surfaceDistance) / mixedSurfaceSmoothness, 0.0f, 1.0f);
    
    float mixedSurfaceDistance = mix(firstSurface.surfaceDistance, secondSurface.surfaceDistance, surfaceDistanceFactor);
    mixedSurfaceDistance = mixedSurfaceDistance - mixedSurfaceSmoothness * surfaceDistanceFactor * (1.0f - surfaceDistanceFactor);
    
    float surfaceMaterialFactor = abs(mixedSurfaceDistance - firstSurface.surfaceDistance) + abs(mixedSurfaceDistance - secondSurface.surfaceDistance);
    surfaceMaterialFactor = clamp(abs(mixedSurfaceDistance - firstSurface.surfaceDistance) / max(surfaceMaterialFactor, 0.000001f), 0.0f, 1.0f);
    
    material mixedSurfaceMaterial;
    mixedSurfaceMaterial.materialAmbientColor.rgb = mix(firstSurface.surfaceMaterial.materialAmbientColor.rgb, secondSurface.surfaceMaterial.materialAmbientColor.rgb, surfaceMaterialFactor).rgb;
    mixedSurfaceMaterial.materialAmbientFactor = mix(firstSurface.surfaceMaterial.materialAmbientFactor, secondSurface.surfaceMaterial.materialAmbientFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialDiffuseColor.rgb = mix(firstSurface.surfaceMaterial.materialDiffuseColor.rgb, secondSurface.surfaceMaterial.materialDiffuseColor.rgb, surfaceMaterialFactor).rgb;
    mixedSurfaceMaterial.materialDiffuseFactor = mix(firstSurface.surfaceMaterial.materialDiffuseFactor, secondSurface.surfaceMaterial.materialDiffuseFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularColor.rgb = mix(firstSurface.surfaceMaterial.materialSpecularColor.rgb, secondSurface.surfaceMaterial.materialSpecularColor.rgb, surfaceMaterialFactor).rgb;
    mixedSurfaceMaterial.materialSpecularFactor = mix(firstSurface.surfaceMaterial.materialSpecularFactor, secondSurface.surfaceMaterial.materialSpecularFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularShininess = mix(firstSurface.surfaceMaterial.materialSpecularShininess, secondSurface.surfaceMaterial.materialSpecularShininess, surfaceMaterialFactor);
    
    surface mixedSurface = surface(mixedSurfaceDistance, mixedSurfaceMaterial);
    
    return mixedSurface;
}

surface getCubeSurface(const in vec3 sceneTransformPosition, const in vec3 cubeTransformPosition, const in vec3 cubeTransformRotation, const in vec3 cubeTransformScale, const in float cubeSurfaceRoundness, const in material cubeSurfaceMaterial)
{
    mat3 cubeTransformOrientation = getTransformEulerOrientation(cubeTransformRotation.xyz);
    
    vec3 cubeTransformCoordinates = abs(cubeTransformOrientation * (sceneTransformPosition.xyz - cubeTransformPosition.xyz).xyz).xyz - cubeTransformScale.xyz;
    cubeTransformCoordinates.xyz = cubeTransformCoordinates.xyz + clamp(cubeSurfaceRoundness, 0.0f, min(min(cubeTransformScale.x, cubeTransformScale.y), cubeTransformScale.z));
    
    float cubeSurfaceDistance = length(max(cubeTransformCoordinates.xyz, vec3(0.0f, 0.0f, 0.0f).xyz)) + min(max(max(cubeTransformCoordinates.x, cubeTransformCoordinates.y), cubeTransformCoordinates.z), 0.0f);
    cubeSurfaceDistance = cubeSurfaceDistance - clamp(cubeSurfaceRoundness, 0.0f, min(min(cubeTransformScale.x, cubeTransformScale.y), cubeTransformScale.z));
    
    surface cubeSurface = surface(cubeSurfaceDistance, cubeSurfaceMaterial);
    
    return cubeSurface;
}

surface getSceneSurface(const in vec3 sampleTransformPosition)
{
    surface cubeGroup01Surface;
    {
        surface cube01Surface;
        {
            vec3 cube01TransformPosition = CameraSettingsFocusPoint.xyz + 25.0f * vec3(0.0f, 0.5f * sqrt(3.0f) * 2.0f / 3.0f, 0.0f);
            cube01TransformPosition.x = cube01TransformPosition.x + 10.0f * (sin(0.1f * 1.5707963f * iTime) + sin(0.4f * 1.5707963f * iTime)) / 2.0f;
            cube01TransformPosition.y = cube01TransformPosition.y + 10.0f * (sin(0.5f * 1.5707963f * iTime) + sin(0.8f * 1.5707963f * iTime)) / 2.0f;
            cube01TransformPosition.z = cube01TransformPosition.z + 10.0f * (sin(0.9f * 1.5707963f * iTime) + sin(0.3f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube01TransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
            cube01TransformRotation.x = cube01TransformRotation.x + 90.0f * (sin(0.1f * 1.5707963f * iTime) + sin(0.4f * 1.5707963f * iTime)) / 2.0f;
            cube01TransformRotation.y = cube01TransformRotation.y + 90.0f * (sin(0.5f * 1.5707963f * iTime) + sin(0.8f * 1.5707963f * iTime)) / 2.0f;
            cube01TransformRotation.z = cube01TransformRotation.z + 90.0f * (sin(0.9f * 1.5707963f * iTime) + sin(0.3f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube01TransformScale = vec3(10.0f, 10.0f, 10.0f).xyz;
           
            float cube01SurfaceRoundness = 2.5f;
           
            material cube01SurfaceMaterial = material(vec3(1.0f, 0.0f, 0.0f).rgb, 0.25f, vec3(1.0f, 0.0f, 0.0f).rgb, 0.75f, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 50.0f);
           
            cube01Surface = getCubeSurface(sampleTransformPosition.xyz, cube01TransformPosition.xyz, cube01TransformRotation.xyz, cube01TransformScale.xyz, cube01SurfaceRoundness, cube01SurfaceMaterial);
        }
       
        surface cube02Surface;
        {
            vec3 cube02TransformPosition = CameraSettingsFocusPoint.xyz + 25.0f * vec3(-0.5f, -0.5f * sqrt(3.0f) / 3.0f, 0.0f).xyz;
            cube02TransformPosition.x = cube02TransformPosition.x + 10.0f * (sin(0.4f * 1.5707963f * iTime) + sin(0.7f * 1.5707963f * iTime)) / 2.0f;
            cube02TransformPosition.y = cube02TransformPosition.y + 10.0f * (sin(0.8f * 1.5707963f * iTime) + sin(0.2f * 1.5707963f * iTime)) / 2.0f;
            cube02TransformPosition.z = cube02TransformPosition.z + 10.0f * (sin(0.3f * 1.5707963f * iTime) + sin(0.6f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube02TransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
            cube02TransformRotation.x = cube02TransformRotation.x + 90.0f * (sin(0.4f * 1.5707963f * iTime) + sin(0.7f * 1.5707963f * iTime)) / 2.0f;
            cube02TransformRotation.y = cube02TransformRotation.y + 90.0f * (sin(0.8f * 1.5707963f * iTime) + sin(0.2f * 1.5707963f * iTime)) / 2.0f;
            cube02TransformRotation.z = cube02TransformRotation.z + 90.0f * (sin(0.3f * 1.5707963f * iTime) + sin(0.6f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube02TransformScale = vec3(10.0f, 10.0f, 10.0f).xyz;
           
            float cube02SurfaceRoundness = 2.5f;
           
            material cube02SurfaceMaterial = material(vec3(0.0f, 1.0f, 0.0f).rgb, 0.25f, vec3(0.0f, 1.0f, 0.0f).rgb, 0.75f, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 50.0f);
           
            cube02Surface = getCubeSurface(sampleTransformPosition.xyz, cube02TransformPosition.xyz, cube02TransformRotation.xyz, cube02TransformScale.xyz, cube02SurfaceRoundness, cube02SurfaceMaterial);
        }
       
        surface cube03Surface;
        {
            vec3 cube03TransformPosition = CameraSettingsFocusPoint.xyz + 25.0f * vec3(0.5f, -0.5f * sqrt(3.0f) / 3.0f, 0.0f).xyz;
            cube03TransformPosition.x = cube03TransformPosition.x + 10.0f * (sin(0.7f * 1.5707963f * iTime) + sin(0.1f * 1.5707963f * iTime)) / 2.0f;
            cube03TransformPosition.y = cube03TransformPosition.y + 10.0f * (sin(0.2f * 1.5707963f * iTime) + sin(0.5f * 1.5707963f * iTime)) / 2.0f;
            cube03TransformPosition.z = cube03TransformPosition.z + 10.0f * (sin(0.6f * 1.5707963f * iTime) + sin(0.9f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube03TransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
            cube03TransformRotation.x = cube03TransformRotation.x + 90.0f * (sin(0.7f * 1.5707963f * iTime) + sin(0.1f * 1.5707963f * iTime)) / 2.0f;
            cube03TransformRotation.y = cube03TransformRotation.y + 90.0f * (sin(0.2f * 1.5707963f * iTime) + sin(0.5f * 1.5707963f * iTime)) / 2.0f;
            cube03TransformRotation.z = cube03TransformRotation.z + 90.0f * (sin(0.6f * 1.5707963f * iTime) + sin(0.9f * 1.5707963f * iTime)) / 2.0f;
           
            vec3 cube03TransformScale = vec3(10.0f, 10.0f, 10.0f).xyz;
           
            float cube03SurfaceRoundness = 2.5f;
           
            material cube03SurfaceMaterial = material(vec3(0.0f, 0.0f, 1.0f).rgb, 0.25f, vec3(0.0f, 0.0f, 1.0f).rgb, 0.75f, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 50.0f);
           
            cube03Surface = getCubeSurface(sampleTransformPosition.xyz, cube03TransformPosition.xyz, cube03TransformRotation.xyz, cube03TransformScale.xyz, cube03SurfaceRoundness, cube03SurfaceMaterial);
        }
       
        float cubeGroup01SurfaceSmoothness = 10.0f;
       
        cubeGroup01Surface = cube01Surface;
        cubeGroup01Surface = getMixedSurface(cubeGroup01Surface, cube02Surface, cubeGroup01SurfaceSmoothness);
        cubeGroup01Surface = getMixedSurface(cubeGroup01Surface, cube03Surface, cubeGroup01SurfaceSmoothness);
    }
   
    surface sceneSurface;
    sceneSurface = cubeGroup01Surface;
   
    return sceneSurface;
}

surface getRaymarchSurface(const in vec3 sampleTransformPosition, const in vec3 sampleTransformDirection)
{
    float raymarchSurfaceDistance = 0.0f;
    
    surface raymarchSurface;
    raymarchSurface.surfaceDistance = raymarchSurfaceDistance;
    
    const float RaymarchSurfaceIterator = 100.0f;
    
    const float RaymarchSurfaceMinimumDistance = 0.0001f;
    const float RaymarchSurfaceMaximumDistance = 500.0f;
    
    for (float raymarchSurfaceCounter = 0.0f; raymarchSurfaceCounter < RaymarchSurfaceIterator; ++raymarchSurfaceCounter)
    {
        raymarchSurface = getSceneSurface(sampleTransformPosition.xyz + raymarchSurfaceDistance * sampleTransformDirection.xyz);
        
        if (raymarchSurface.surfaceDistance < RaymarchSurfaceMinimumDistance || raymarchSurfaceDistance > RaymarchSurfaceMaximumDistance) break;
        
        raymarchSurfaceDistance = raymarchSurfaceDistance + raymarchSurface.surfaceDistance;
    }
    
    raymarchSurface.surfaceDistance = raymarchSurfaceDistance;
    
    return raymarchSurface;
}

void setFragmentForegroundColor(inout vec3 fragmentOutputColor, const in vec3 cameraTransformPosition, const in vec3 cameraTransformDirection, const in vec3 surfaceTransformPosition, const in vec3 surfaceTransformDirection, const in pointlight pointlight, const in material surfaceMaterial)
{
    vec3 observerTransformDirection = normalize(cameraTransformPosition.xyz - surfaceTransformPosition.xyz).xyz;
    observerTransformDirection.xyz = (length(observerTransformDirection.xyz) > 0.000001f ? observerTransformDirection.xyz : cameraTransformDirection.xyz).xyz;
    
    vec3 lightingTransformDirection = normalize(pointlight.pointlightTransformPosition.xyz - surfaceTransformPosition.xyz).xyz;
    
    vec3 brightnessTransformDirection = normalize(observerTransformDirection.xyz + lightingTransformDirection.xyz).xyz;
    brightnessTransformDirection.xyz = (length(brightnessTransformDirection.xyz) > 0.000001f ? brightnessTransformDirection.xyz : lightingTransformDirection.xyz).xyz;
    
    float pointlightEmissionAttenuation = clamp(length(pointlight.pointlightTransformPosition.xyz - surfaceTransformPosition.xyz) / pointlight.pointlightEmissionMaximumDistance, 0.0f, 1.0f);
    pointlightEmissionAttenuation = (1.0f - pointlightEmissionAttenuation * pointlightEmissionAttenuation) * (1.0f - pointlightEmissionAttenuation * pointlightEmissionAttenuation);
    
    float surfaceMaterialAmbientStrength = clamp(0.5f + 0.5f * dot(surfaceTransformDirection.xyz, lightingTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(surfaceMaterial.materialAmbientFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(pointlight.pointlightEmissionAmbientFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(pointlightEmissionAttenuation, 0.0f, 1.0f);
    
    float surfaceMaterialDiffuseStrength = clamp(dot(surfaceTransformDirection.xyz, lightingTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(surfaceMaterial.materialDiffuseFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(pointlight.pointlightEmissionDiffuseFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(pointlightEmissionAttenuation, 0.0f, 1.0f);
    
    const float SurfaceMaterialSpecularMinimumPower = 0.0f;
    const float SurfaceMaterialSpecularMaximumPower = 100.0f;
    float surfaceMaterialSpecularPower = clamp(surfaceMaterial.materialSpecularShininess, SurfaceMaterialSpecularMinimumPower, SurfaceMaterialSpecularMaximumPower);
    
    float surfaceMaterialSpecularStrength = clamp(dot(surfaceTransformDirection.xyz, brightnessTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = pow(surfaceMaterialSpecularStrength, surfaceMaterialSpecularPower);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(surfaceMaterial.materialSpecularFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(pointlight.pointlightEmissionSpecularFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(pointlightEmissionAttenuation, 0.0f, 1.0f);
    
    vec3 surfaceMaterialAmbientLighting = surfaceMaterialAmbientStrength * clamp(surfaceMaterial.materialAmbientColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialAmbientLighting.rgb = surfaceMaterialAmbientLighting.rgb * clamp(pointlight.pointlightEmissionAmbientColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    
    vec3 surfaceMaterialDiffuseLighting = surfaceMaterialDiffuseStrength * clamp(surfaceMaterial.materialDiffuseColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialDiffuseLighting.rgb = surfaceMaterialDiffuseLighting.rgb * clamp(pointlight.pointlightEmissionDiffuseColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    
    vec3 surfaceMaterialSpecularLighting = surfaceMaterialSpecularStrength * clamp(surfaceMaterial.materialSpecularColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialSpecularLighting.rgb = surfaceMaterialSpecularLighting.rgb * clamp(pointlight.pointlightEmissionSpecularColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    
    fragmentOutputColor.rgb = fragmentOutputColor.rgb + (surfaceMaterialAmbientLighting.rgb + surfaceMaterialDiffuseLighting.rgb + surfaceMaterialSpecularLighting.rgb).rgb;
}

void setFragmentForegroundColor(
    inout vec3 fragmentOutputColor,
    const in vec3 cameraTransformPosition,
    const in vec3 cameraTransformDirection,
    const in vec3 surfaceTransformPosition,
    const in vec3 surfaceTransformDirection,
    const in spotlight spotlight,
    const in material surfaceMaterial
)
{
    // Dirección al observador
    vec3 observerTransformDirection =
        normalize(cameraTransformPosition.xyz - surfaceTransformPosition.xyz);
    observerTransformDirection =
        (length(observerTransformDirection) > 0.000001f)
        ? observerTransformDirection
        : cameraTransformDirection;

    // Dirección a la luz
    vec3 lightingTransformDirection =
        normalize(spotlight.spotlightTransformPosition.xyz - surfaceTransformPosition.xyz);

    // Blinn-Phong half vector
    vec3 brightnessTransformDirection =
        normalize(observerTransformDirection + lightingTransformDirection);
    brightnessTransformDirection =
        (length(brightnessTransformDirection) > 0.000001f)
        ? brightnessTransformDirection
        : lightingTransformDirection;

    // ==============================
    // Atenuación por distancia
    // ==============================
    float spotlightEmissionAttenuation =
        clamp(
            length(spotlight.spotlightTransformPosition.xyz - surfaceTransformPosition.xyz)
            / spotlight.spotlightEmissionMaximumDistance,
            0.0f, 1.0f
        );

    spotlightEmissionAttenuation =
        (1.0f - spotlightEmissionAttenuation * spotlightEmissionAttenuation);
    spotlightEmissionAttenuation *= spotlightEmissionAttenuation;

    // ==============================
    // Atenuación por cono (spot)
    // ==============================
    float theta =
        dot(
            lightingTransformDirection,
            normalize(-spotlight.spotlightTransformDirection)
        );

    float epsilon =
        spotlight.spotlightInnerCutoff - spotlight.spotlightOuterCutoff;

    float spotlightIntensity =
        clamp(
            (theta - spotlight.spotlightOuterCutoff) / max(epsilon, 0.00001f),
            0.0f, 1.0f
        );

    float finalAttenuation =
        spotlightEmissionAttenuation * spotlightIntensity;

    // ==============================
    // AMBIENT
    // ==============================
    float surfaceMaterialAmbientStrength =
        clamp(0.5f + 0.5f * dot(surfaceTransformDirection, lightingTransformDirection),
              0.0f, 1.0f);

    surfaceMaterialAmbientStrength *=
        clamp(surfaceMaterial.materialAmbientFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength *=
        clamp(spotlight.spotlightEmissionAmbientFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength *=
        finalAttenuation;

    // ==============================
    // DIFFUSE
    // ==============================
    float surfaceMaterialDiffuseStrength =
        clamp(dot(surfaceTransformDirection, lightingTransformDirection),
              0.0f, 1.0f);

    surfaceMaterialDiffuseStrength *=
        clamp(surfaceMaterial.materialDiffuseFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength *=
        clamp(spotlight.spotlightEmissionDiffuseFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength *=
        finalAttenuation;

    // ==============================
    // SPECULAR
    // ==============================
    float specularPower =
        clamp(surfaceMaterial.materialSpecularShininess, 0.0f, 100.0f);

    float surfaceMaterialSpecularStrength =
        clamp(dot(surfaceTransformDirection, brightnessTransformDirection),
              0.0f, 1.0f);

    surfaceMaterialSpecularStrength =
        pow(surfaceMaterialSpecularStrength, specularPower);

    surfaceMaterialSpecularStrength *=
        clamp(surfaceMaterial.materialSpecularFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength *=
        clamp(spotlight.spotlightEmissionSpecularFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength *=
        finalAttenuation;

    // ==============================
    // Composición final
    // ==============================
    vec3 ambient =
        surfaceMaterialAmbientStrength *
        surfaceMaterial.materialAmbientColor *
        spotlight.spotlightEmissionAmbientColor;

    vec3 diffuse =
        surfaceMaterialDiffuseStrength *
        surfaceMaterial.materialDiffuseColor *
        spotlight.spotlightEmissionDiffuseColor;

    vec3 specular =
        surfaceMaterialSpecularStrength *
        surfaceMaterial.materialSpecularColor *
        spotlight.spotlightEmissionSpecularColor;

    fragmentOutputColor += ambient + diffuse + specular;
}

void setFragmentForegroundColor(inout vec3 fragmentOutputColor, const in vec3 cameraTransformPosition, const in vec3 cameraTransformDirection, const in surface raymarchSurface)
{
    vec3 surfaceTransformPosition = cameraTransformPosition.xyz + raymarchSurface.surfaceDistance * cameraTransformDirection.xyz;
    
    vec3 surfaceTransformDirection = vec3(0.0f, 0.0f, 0.0f).xyz;
    surfaceTransformDirection.x = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0001f, 0.0f, 0.0f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0001f, 0.0f, 0.0f).xyz).surfaceDistance;
    surfaceTransformDirection.y = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0f, 0.0001f, 0.0f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0f, 0.0001f, 0.0f).xyz).surfaceDistance;
    surfaceTransformDirection.z = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0f, 0.0f, 0.0001f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0f, 0.0f, 0.0001f).xyz).surfaceDistance;
    surfaceTransformDirection.xyz = normalize(surfaceTransformDirection.xyz).xyz;
    
    pointlight pointlight01 = pointlight(vec3(-100.0f, 100.0f, -100.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, 200.0f);
    
    setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight01, raymarchSurface.surfaceMaterial);
    
    pointlight pointlight02 = pointlight(vec3(100.0f, 100.f, -100.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, 200.0f);
    
    setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight02, raymarchSurface.surfaceMaterial);
    
    pointlight pointlight03 = pointlight(vec3(-100.0f, 100.0f, 100.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, 200.0f);
    
    setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight03, raymarchSurface.surfaceMaterial);
    
    pointlight pointlight04 = pointlight(vec3(100.0f, 100.0f, 100.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, vec3(1.0f, 1.0f, 1.0f).rgb, 0.1f, 200.0f);
    
    setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight04, raymarchSurface.surfaceMaterial);
    
    spotlight spotlight01 = spotlight(
    vec3(0.0f, 100.0f, -50.0f),          // posición
    normalize(vec3(0.0) - vec3(0.0f, 100., -50.0f)), // dirección
    cos(radians(5.0f)),             // inner
    cos(radians(10.0f)),             // outer
    vec3(1.0f), 1.0f,
    vec3(1.0f), 1.0f,
    vec3(1.0f), 1.0f,
    200.0f
);

setFragmentForegroundColor(
    fragmentOutputColor.rgb,
    cameraTransformPosition,
    cameraTransformDirection,
    surfaceTransformPosition,
    surfaceTransformDirection,
    spotlight01,
    raymarchSurface.surfaceMaterial);



spotlight spotlight02 = spotlight(
    vec3(0.0f, 100.0f, 50.0f),          // posición
    normalize(vec3(0.0) - vec3(0.0f, 100., 50.0f)), // dirección
    cos(radians(5.0f)),             // inner
    cos(radians(10.0f)),             // outer
    vec3(1.0f), 1.0f,
    vec3(1.0f), 1.0f,
    vec3(1.0f), 1.0f,
    200.0f
);

setFragmentForegroundColor(
    fragmentOutputColor.rgb,
    cameraTransformPosition,
    cameraTransformDirection,
    surfaceTransformPosition,
    surfaceTransformDirection,
    spotlight02,
    raymarchSurface.surfaceMaterial);
}


void setFragmentBackgroundColor(inout vec3 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec3 fragmentTileEvenColor, const in vec3 fragmentTileOddColor, const in float fragmentTileDimension, const in vec3 fragmentLineColor, const in float fragmentLineDimension)
{
    vec2 fragmentOffsetCoordinates = (iResolution.x < iResolution.y ? vec2(1.0f, 0.0f).xy : iResolution.x > iResolution.y ? vec2(0.0f, 1.0f).xy : vec2(0.0f, 0.0f).xy).xy;
    
    vec2 fragmentTileCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentTileCoordinates.xy = fragmentTileCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentTileCoordinates.xy = floor(fragmentTileCoordinates.xy / vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;
    
    float fragmentTileChecker = step(fragmentTileDimension, mod(fragmentTileCoordinates.x + fragmentTileCoordinates.y, 2.0f));
    
    fragmentOutputColor.rgb = mix(fragmentTileEvenColor.rgb, fragmentTileOddColor.rgb, fragmentTileChecker).rgb;
    
    vec2 fragmentLineCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentLineCoordinates.xy = fragmentLineCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentLineCoordinates.xy = mod(fragmentLineCoordinates.xy, vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;
    
    float fragmentLineChecker = step(min(fragmentLineCoordinates.x, fragmentLineCoordinates.y), fragmentLineDimension);
    
    fragmentOutputColor.rgb = mix(fragmentOutputColor.rgb, fragmentLineColor.rgb, fragmentLineChecker).rgb;
    
}

void setVignetteImageProcessing(inout vec3 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec3 vignetteSurfaceColor, const in float vignetteTransformScale, const in float vignetteSurfaceRoundness, const in float vignetteSurfaceSmoothness)
{
    vec2 vignetteTransformPosition = abs((2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / iResolution.xy).xy;
    vignetteTransformPosition.xy = vignetteTransformPosition.xy - vec2(vignetteTransformScale * (1.0f - vignetteSurfaceRoundness), vignetteTransformScale * (1.0f - vignetteSurfaceRoundness)).xy;
    
    float vignetteSurfaceDistance = length(max(vignetteTransformPosition.xy, vec2(0.0f, 0.0f).xy).xy) + min(max(vignetteTransformPosition.x, vignetteTransformPosition.y), 0.0f);
    vignetteSurfaceDistance = smoothstep(0.0f, vignetteSurfaceSmoothness, vignetteSurfaceDistance - vignetteTransformScale * vignetteSurfaceRoundness);
    
    fragmentOutputColor.rgb = mix(fragmentOutputColor.rgb, vignetteSurfaceColor.rgb, vignetteSurfaceDistance).rgb;
}

void setGammaCorrectionImageProcessing(inout vec3 fragmentOutputColor)
{
    fragmentOutputColor.rgb = clamp(fragmentOutputColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    
    vec3 gammaCorrectionLowerBranch = vec3(12.92f, 12.92f, 12.92f).rgb * fragmentOutputColor.rgb;
    
    vec3 gammaCorrectionUpperBranch = vec3(1.055f, 1.055f, 1.055f).rgb * pow(fragmentOutputColor.rgb, vec3(1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f).rgb).rgb - vec3(0.055f, 0.055f, 0.055f).rgb;
    
    vec3 gammaCorrectionBranchSelector = step(vec3(0.0031308f, 0.0031308f, 0.0031308f).rgb, fragmentOutputColor.rgb).rgb;
    
    fragmentOutputColor.rgb = mix(gammaCorrectionLowerBranch.rgb, gammaCorrectionUpperBranch.rgb, gammaCorrectionBranchSelector.rgb).rgb;
}

void mainImage(out vec4 fragmentOutputColor, in vec2 fragmentInputCoordinates)
{
    fragmentOutputColor.rgb = vec4(0.0f, 0.0f, 0.0f, 1.0f).rgb;
    
    vec3 cameraTransformPosition = vec3(0.0f, 0.0f, 0.0f).xyz;
    {
        vec3 cameraSettingsOrbitalAxis = vec3(radians(45.0f) + iTime, radians(45.0f), 50.0f).xyz;
        
        vec3 cameraSettingsOrbitalPoint = vec3(0.0f, 0.0f, 0.0f).xyz;
        cameraSettingsOrbitalPoint.x = cameraSettingsOrbitalAxis.z * cos(cameraSettingsOrbitalAxis.y) * cos(cameraSettingsOrbitalAxis.x);
        cameraSettingsOrbitalPoint.y = cameraSettingsOrbitalAxis.z * sin(cameraSettingsOrbitalAxis.y);
        cameraSettingsOrbitalPoint.z = cameraSettingsOrbitalAxis.z * cos(cameraSettingsOrbitalAxis.y) * sin(cameraSettingsOrbitalAxis.x);
        
        cameraTransformPosition.xyz = CameraSettingsFocusPoint.xyz + cameraSettingsOrbitalPoint.xyz;
    }
    
    vec3 cameraTransformDirection = vec3(0.0f, 0.0f, 0.0f).xyz;
    {
        mat3 cameraTransformOrientation = getTransformLookAtOrientation(cameraTransformPosition.xyz, CameraSettingsFocusPoint.xyz);
        
        vec2 cameraSettingsViewport = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
        
        const float CameraSettingsMinimumFieldOfView = 10.0f;
        const float CameraSettingsMaximumFieldOfView = 170.0f;
        float cameraSettingsFieldOfView = clamp(60.0f, CameraSettingsMinimumFieldOfView, CameraSettingsMaximumFieldOfView);
        
        float cameraSettingsFocalLength = 1.0f / tan(0.5f * radians(cameraSettingsFieldOfView));
        
        cameraTransformDirection.xyz = cameraTransformOrientation * normalize(vec3(cameraSettingsViewport.x, cameraSettingsViewport.y, -cameraSettingsFocalLength).xyz).xyz;
    }
    
    surface raymarchSurface = getRaymarchSurface(cameraTransformPosition.xyz, cameraTransformDirection.xyz);
    
    const float CameraSettingsNearClippingPlane = 0.0001f;
    const float CameraSettingsFarClippingPlane = 500.0f;
    
    if (raymarchSurface.surfaceDistance < CameraSettingsNearClippingPlane || raymarchSurface.surfaceDistance > CameraSettingsFarClippingPlane)
    {
        setFragmentBackgroundColor(fragmentOutputColor.rgb, fragmentInputCoordinates.xy, vec3(1.0f / 20.0f, 1.0f / 20.0f, 1.0f / 20.0f).rgb, vec3(1.0f / 10.0f, 1.0f / 10.0f, 1.0f / 10.0f).rgb, 0.25f, vec3(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f).rgb, 0.01f);
    }
    else
    {
        setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, raymarchSurface);
    }
    
    setVignetteImageProcessing(fragmentOutputColor.rgb, fragmentInputCoordinates.xy, vec3(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f).rgb, 0.5f, 0.5f, 0.5f);
    
    setGammaCorrectionImageProcessing(fragmentOutputColor.rgb);
    
    fragmentOutputColor.rgba = vec4(fragmentOutputColor.r, fragmentOutputColor.g, fragmentOutputColor.b, 1.0f);
}
