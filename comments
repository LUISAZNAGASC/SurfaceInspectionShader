vec3 cameraSettingsOrbitalPoint;
cameraSettingsOrbitalPoint.x = cameraSettingsOrbitalDistance * cos(cameraSettingsOrbitalElevation) * cos(iTime + cameraSettingsOrbitalAzimuth);
cameraSettingsOrbitalPoint.y = cameraSettingsOrbitalDistance * sin(cameraSettingsOrbitalElevation);
cameraSettingsOrbitalPoint.z = cameraSettingsOrbitalDistance * cos(cameraSettingsOrbitalElevation) * sin(iTime + cameraSettingsOrbitalAzimuth);

cameraSettingsOrbitalDistance
cameraSettingsOrbitalHorizontal
cameraSettingsOrbitalVertical
cameraSettingsOrbitalPoint
cameraSettingsLookAtPoint

cameraSettingsViewport
cameraSettingsMinimumFieldOfView
cameraSettingsMaximumFieldOfView
cameraSettingsFieldOfView
cameraSettingsFocalLength


struct material { vec3 materialAlbedoColor; float materialAmbientFactor; float materialDiffuseFactor; float materialSpecularFactor; float materialSpecularShininess; };

struct surface { float surfaceDistance; material surfaceMaterial; };

mat3 getTransformEulerOrientation(const in vec3 transformTargetRotation)
{
    vec3 transformSineRotation = sin(radians(transformTargetRotation.xyz).xyz).xyz;

    vec3 transformCosineRotation = cos(radians(transformTargetRotation.xyz).xyz).xyz;

    mat3 transformPitchOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformPitchOrientation[0u].xyz = vec3(1.0f, 0.0f, 0.0f).xyz;
    transformPitchOrientation[1u].xyz = vec3(0.0f, transformCosineRotation.x, -transformSineRotation.x).xyz;
    transformPitchOrientation[2u].xyz = vec3(0.0f, transformSineRotation.x, transformCosineRotation.x).xyz;

    mat3 transformYawOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformYawOrientation[0u].xyz = vec3(transformCosineRotation.y, 0.0f, transformSineRotation.y).xyz;
    transformYawOrientation[1u].xyz = vec3(0.0f, 1.0f, 0.0f).xyz;
    transformYawOrientation[2u].xyz = vec3(-transformSineRotation.y, 0.0f, transformCosineRotation.y).xyz;

    mat3 transformRollOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformRollOrientation[0u].xyz = vec3(transformCosineRotation.z, -transformSineRotation.z, 0.0f).xyz;
    transformRollOrientation[1u].xyz = vec3(transformSineRotation.z, transformCosineRotation.z, 0.0f).xyz;
    transformRollOrientation[2u].xyz = vec3(0.0f, 0.0f, 1.0f).xyz;

    mat3 transformEulerOrientation = transformPitchOrientation * transformYawOrientation * transformRollOrientation;

    return transformEulerOrientation;
}

surface getMixedSurface(const in surface firstSurface, const in surface secondSurface, const in float mixedSurfaceSmoothness)
{
    float surfaceDistanceFactor = clamp(0.5f + 0.5f * (firstSurface.surfaceDistance - secondSurface.surfaceDistance) / mixedSurfaceSmoothness, 0.0f, 1.0f);

    float mixedSurfaceDistance = mix(firstSurface.surfaceDistance, secondSurface.surfaceDistance, surfaceDistanceFactor);
    mixedSurfaceDistance = mixedSurfaceDistance - mixedSurfaceSmoothness * surfaceDistanceFactor * (1.0f - surfaceDistanceFactor);

    float surfaceMaterialFactor = abs(mixedSurfaceDistance - firstSurface.surfaceDistance) + abs(mixedSurfaceDistance - secondSurface.surfaceDistance);
    surfaceMaterialFactor = clamp(abs(mixedSurfaceDistance - firstSurface.surfaceDistance) / max(surfaceMaterialFactor, 0.000001f), 0.0f, 1.0f);

    material mixedSurfaceMaterial;
    mixedSurfaceMaterial.materialAlbedoColor.rgb = mix(firstSurface.surfaceMaterial.materialAlbedoColor.rgb, secondSurface.surfaceMaterial.materialAlbedoColor.rgb, surfaceMaterialFactor).rgb;
    mixedSurfaceMaterial.materialAmbientFactor = mix(firstSurface.surfaceMaterial.materialAmbientFactor, secondSurface.surfaceMaterial.materialAmbientFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialDiffuseFactor = mix(firstSurface.surfaceMaterial.materialDiffuseFactor, secondSurface.surfaceMaterial.materialDiffuseFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularFactor = mix(firstSurface.surfaceMaterial.materialSpecularFactor, secondSurface.surfaceMaterial.materialSpecularFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularShininess = mix(firstSurface.surfaceMaterial.materialSpecularShininess, secondSurface.surfaceMaterial.materialSpecularShininess, surfaceMaterialFactor);

    surface mixedSurface = surface(mixedSurfaceDistance, mixedSurfaceMaterial);

    return mixedSurface;
}

surface getCubeSurface(const in vec3 sceneTransformPosition, const in vec3 cubeTransformPosition, const in vec3 cubeTransformRotation, const in vec3 cubeTransformScale, const in float cubeSurfaceRoundness, const in material cubeSurfaceMaterial)
{
    mat3 cubeTransformOrientation = getTransformEulerOrientation(cubeTransformRotation.xyz);
    
    vec3 cubeTransformCoordinates = abs(cubeTransformOrientation * (sceneTransformPosition.xyz - cubeTransformPosition.xyz).xyz).xyz - cubeTransformScale.xyz;
    cubeTransformCoordinates.xyz = cubeTransformCoordinates.xyz + clamp(cubeSurfaceRoundness, 0.0f, min(min(cubeTransformScale.x, cubeTransformScale.y), cubeTransformScale.z));
    
    float cubeSurfaceDistance = length(max(cubeTransformCoordinates.xyz, vec3(0.0f, 0.0f, 0.0f).xyz)) + min(max(max(cubeTransformCoordinates.x, cubeTransformCoordinates.y), cubeTransformCoordinates.z), 0.0f);
    cubeSurfaceDistance = cubeSurfaceDistance - clamp(cubeSurfaceRoundness, 0.0f, min(min(cubeTransformScale.x, cubeTransformScale.y), cubeTransformScale.z));
    
    surface cubeSurface = surface(cubeSurfaceDistance, cubeSurfaceMaterial);
    
    return cubeSurface;
}

void mainImage(out vec4 fragmentOutputColor, in vec2 fragmentInputCoordinates)
{
    
}
