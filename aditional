struct pointlight { vec3 pointlightTransformPosition; vec3 pointlightEmissiveColor; float pointlightEmissiveFactor; float pointlightEmissiveRange; };

struct material { vec3 materialAlbedoColor; float materialAmbientFactor; float materialDiffuseFactor; float materialSpecularFactor; float materialSpecularShininess; };

struct surface { float surfaceDistance; material surfaceMaterial; };

const vec3 CameraTransformLookAtPoint = vec3(0.0f, 0.0f, 0.0f).xyz;

mat3 getTransformEulerOrientation(const in vec3 transformTargetRotation)
{
    vec3 transformSineRotation = sin(radians(transformTargetRotation.xyz).xyz).xyz;

    vec3 transformCosineRotation = cos(radians(transformTargetRotation.xyz).xyz).xyz;

    mat3 transformPitchOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformPitchOrientation[0u].xyz = vec3(1.0f, 0.0f, 0.0f).xyz;
    transformPitchOrientation[1u].xyz = vec3(0.0f, transformCosineRotation.x, -transformSineRotation.x).xyz;
    transformPitchOrientation[2u].xyz = vec3(0.0f, transformSineRotation.x, transformCosineRotation.x).xyz;

    mat3 transformYawOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformYawOrientation[0u].xyz = vec3(transformCosineRotation.y, 0.0f, transformSineRotation.y).xyz;
    transformYawOrientation[1u].xyz = vec3(0.0f, 1.0f, 0.0f).xyz;
    transformYawOrientation[2u].xyz = vec3(-transformSineRotation.y, 0.0f, transformCosineRotation.y).xyz;

    mat3 transformRollOrientation = mat3(vec3(1.0f, 0.0f, 0.0f).xyz, vec3(0.0f, 1.0f, 0.0f).xyz, vec3(0.0f, 0.0f, 1.0f).xyz);
    transformRollOrientation[0u].xyz = vec3(transformCosineRotation.z, -transformSineRotation.z, 0.0f).xyz;
    transformRollOrientation[1u].xyz = vec3(transformSineRotation.z, transformCosineRotation.z, 0.0f).xyz;
    transformRollOrientation[2u].xyz = vec3(0.0f, 0.0f, 1.0f).xyz;

    mat3 transformEulerOrientation = transformPitchOrientation * transformYawOrientation * transformRollOrientation;

    return transformEulerOrientation;
}

mat3 getTransformLookAtOrientation(const in vec3 transformOriginPosition, const in vec3 transformTargetPosition)
{
    vec3 transformForwardDirection = normalize(transformTargetPosition.xyz - transformOriginPosition.xyz).xyz;

    vec3 transformRightwardDirection = normalize(cross(vec3(0.0f, 1.0f, 0.0f).xyz, transformForwardDirection.xyz).xyz).xyz;

    vec3 transformUpwardDirection = normalize(cross(transformForwardDirection.xyz, transformRightwardDirection.xyz).xyz).xyz;

    mat3 transformLookAtOrientation = mat3(-transformRightwardDirection.xyz, transformUpwardDirection.xyz, -transformForwardDirection.xyz);

    return transformLookAtOrientation;
}

surface getMixedSurface(const in surface firstSurface, const in surface secondSurface, const in float mixedSurfaceSmoothness)
{
    float surfaceDistanceFactor = clamp(0.5f + 0.5f * (firstSurface.surfaceDistance - secondSurface.surfaceDistance) / mixedSurfaceSmoothness, 0.0f, 1.0f);

    float mixedSurfaceDistance = mix(firstSurface.surfaceDistance, secondSurface.surfaceDistance, surfaceDistanceFactor);
    mixedSurfaceDistance = mixedSurfaceDistance - mixedSurfaceSmoothness * surfaceDistanceFactor * (1.0f - surfaceDistanceFactor);

    float surfaceMaterialFactor = abs(mixedSurfaceDistance - firstSurface.surfaceDistance) + abs(mixedSurfaceDistance - secondSurface.surfaceDistance);
    surfaceMaterialFactor = clamp(abs(mixedSurfaceDistance - firstSurface.surfaceDistance) / max(surfaceMaterialFactor, 0.000001f), 0.0f, 1.0f);

    material mixedSurfaceMaterial;
    mixedSurfaceMaterial.materialAlbedoColor.rgb = mix(firstSurface.surfaceMaterial.materialAlbedoColor.rgb, secondSurface.surfaceMaterial.materialAlbedoColor.rgb, surfaceMaterialFactor).rgb;
    mixedSurfaceMaterial.materialAmbientFactor = mix(firstSurface.surfaceMaterial.materialAmbientFactor, secondSurface.surfaceMaterial.materialAmbientFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialDiffuseFactor = mix(firstSurface.surfaceMaterial.materialDiffuseFactor, secondSurface.surfaceMaterial.materialDiffuseFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularFactor = mix(firstSurface.surfaceMaterial.materialSpecularFactor, secondSurface.surfaceMaterial.materialSpecularFactor, surfaceMaterialFactor);
    mixedSurfaceMaterial.materialSpecularShininess = mix(firstSurface.surfaceMaterial.materialSpecularShininess, secondSurface.surfaceMaterial.materialSpecularShininess, surfaceMaterialFactor);

    surface mixedSurface = surface(mixedSurfaceDistance, mixedSurfaceMaterial);

    return mixedSurface;
}

surface getSphereSurface(const in vec3 sceneTransformPosition, const in vec3 sphereTransformPosition, const in vec3 sphereTransformRotation, const in float sphereTransformRadius, const in material sphereSurfaceMaterial)
{
    mat3 sphereTransformOrientation = getTransformEulerOrientation(sphereTransformRotation.xyz);
    
    vec3 sphereTransformCoordinates = sphereTransformOrientation * (sceneTransformPosition.xyz - sphereTransformPosition.xyz).xyz;
    
    float sphereSurfaceDistance = length(sphereTransformCoordinates.xyz) - abs(sphereTransformRadius);
    
    surface sphereSurface = surface(sphereSurfaceDistance, sphereSurfaceMaterial);
    
    return sphereSurface;
}

float sdRoundBox(vec3 p, vec3 b, float r)
{
    vec3 q = abs(p) - b + r;
    return length(max(q, 0.0)) 
         + min(max(q.x, max(q.y, q.z)), 0.0) 
         - r;
}
surface getRoundedCubeSurface(
    const in vec3 sceneTransformPosition,
    const in vec3 cubeTransformPosition,
    const in vec3 cubeTransformRotation,
    const in vec3 cubeHalfExtent,
    const in float cubeRoundRadius,
    const in material cubeSurfaceMaterial
)
{
    // Orientación del cubo (rotación)
    mat3 cubeTransformOrientation =
        getTransformEulerOrientation(cubeTransformRotation.xyz);

    // Transformar el punto de la escena al espacio local del cubo
    vec3 cubeLocalPosition =
        cubeTransformOrientation * (sceneTransformPosition - cubeTransformPosition);

    // Distancia SDF al cubo redondeado
    float cubeSurfaceDistance =
        sdRoundBox(cubeLocalPosition, cubeHalfExtent, cubeRoundRadius);

    // Resultado final
    return surface(cubeSurfaceDistance, cubeSurfaceMaterial);
}

vec3 hash33(vec3 p)
{
    p = fract(p * 0.1031);
    p += dot(p, p.yzx + 33.33);
    return fract((p.xxy + p.yzz) * p.zyx);
}

vec3 randomVec3(vec3 pos, float time)
{
float t0 = floor(time);
    float t1 = t0 + 1.0;

    vec3 r0 = hash33(pos + t0);
    vec3 r1 = hash33(pos + t1);

    // Curva suave (no lineal)
    float f = fract(time);
    f = f * f * (3.0 - 2.0 * f); // smoothstep

    return mix(r0, r1, f);
}


surface getSceneSurface(const in vec3 sampleTransformPosition)
{
    // Base
    vec3 basePosition = CameraTransformLookAtPoint;

    // Offset aleatorio estable
    vec3 randomOffset =
        (randomVec3(basePosition, iTime) - 0.5) * 10.0;

    vec3 cubePosition = basePosition + randomOffset;

    surface sceneSurface =
        getRoundedCubeSurface(
            sampleTransformPosition,
            cubePosition,
            vec3(0.0),
            vec3(15.0),
            7.5,
            material(vec3(0.0, 1.0, 0.0), 0.25, 0.75, 1.0, 25.0)
        );

    return sceneSurface;
}


surface getRaymarchSurface(const in vec3 sampleTransformPosition, const in vec3 sampleTransformDirection)
{
    float raymarchSurfaceDistance = 0.0f;
    
    surface raymarchSurface;
    raymarchSurface.surfaceDistance = raymarchSurfaceDistance;
    
    const float RaymarchSurfaceIterator = 100.0f;
    
    const float RaymarchSurfaceMinimumDistance = 0.0001f;
    const float RaymarchSurfaceMaximumDistance = 500.0f;
    
    for (float raymarchSurfaceCounter = 0.0f; raymarchSurfaceCounter < RaymarchSurfaceIterator; ++raymarchSurfaceCounter)
    {
        raymarchSurface = getSceneSurface(sampleTransformPosition.xyz + raymarchSurfaceDistance * sampleTransformDirection.xyz);
        
        if (raymarchSurface.surfaceDistance < RaymarchSurfaceMinimumDistance || raymarchSurfaceDistance > RaymarchSurfaceMaximumDistance) break;
        
        raymarchSurfaceDistance = raymarchSurfaceDistance + raymarchSurface.surfaceDistance;
    }
    
    raymarchSurface.surfaceDistance = raymarchSurfaceDistance;
    
    return raymarchSurface;
}

void setFragmentForegroundColor(inout vec3 fragmentOutputColor, const in vec3 cameraTransformPosition, const in vec3 cameraTransformDirection, const in vec3 surfaceTransformPosition, const in vec3 surfaceTransformDirection, const in pointlight pointlight, const in material surfaceMaterial)
{
    vec3 observerTransformDirection = normalize(cameraTransformPosition.xyz - surfaceTransformPosition.xyz).xyz;
    observerTransformDirection.xyz = (length(observerTransformDirection.xyz) > 0.000001f ? observerTransformDirection.xyz : cameraTransformDirection.xyz).xyz;

    vec3 lightingTransformDirection = normalize(pointlight.pointlightTransformPosition.xyz - surfaceTransformPosition.xyz).xyz;

    vec3 brightnessTransformDirection = normalize(lightingTransformDirection.xyz + observerTransformDirection.xyz).xyz;
    brightnessTransformDirection.xyz = (length(brightnessTransformDirection.xyz) > 0.000001f ? brightnessTransformDirection.xyz : lightingTransformDirection.xyz).xyz;

    float pointlightTransformDistance = length(pointlight.pointlightTransformPosition.xyz - surfaceTransformPosition.xyz);

    float pointlightAttenuationFactor = clamp(pointlightTransformDistance / pointlight.pointlightEmissiveRange, 0.0f, 1.0f);
    pointlightAttenuationFactor = 1.0f - pointlightAttenuationFactor * pointlightAttenuationFactor;
    pointlightAttenuationFactor = pointlightAttenuationFactor * pointlightAttenuationFactor;

    float surfaceMaterialAmbientStrength = clamp(0.5f + 0.5f * dot(surfaceTransformDirection.xyz, lightingTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(surfaceMaterial.materialAmbientFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(pointlight.pointlightEmissiveFactor, 0.0f, 1.0f);
    surfaceMaterialAmbientStrength = surfaceMaterialAmbientStrength * clamp(pointlightAttenuationFactor, 0.0f, 1.0f);

    float surfaceMaterialDiffuseStrength = clamp(dot(surfaceTransformDirection.xyz, lightingTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(surfaceMaterial.materialDiffuseFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(pointlight.pointlightEmissiveFactor, 0.0f, 1.0f);
    surfaceMaterialDiffuseStrength = surfaceMaterialDiffuseStrength * clamp(pointlightAttenuationFactor, 0.0f, 1.0f);

    const float SurfaceMaterialSpecularMinimumPower = 0.0f;
    const float SurfaceMaterialSpecularMaximumPower = 100.0f;
    float surfaceMaterialSpecularPower = clamp(surfaceMaterial.materialSpecularShininess, SurfaceMaterialSpecularMinimumPower, SurfaceMaterialSpecularMaximumPower);
    float surfaceMaterialSpecularStrength = clamp(dot(brightnessTransformDirection.xyz, surfaceTransformDirection.xyz), 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = pow(surfaceMaterialSpecularStrength, surfaceMaterialSpecularPower);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(surfaceMaterial.materialSpecularFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(pointlight.pointlightEmissiveFactor, 0.0f, 1.0f);
    surfaceMaterialSpecularStrength = surfaceMaterialSpecularStrength * clamp(pointlightAttenuationFactor, 0.0f, 1.0f);

    vec3 surfaceMaterialAmbientColor = clamp(surfaceMaterial.materialAlbedoColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialAmbientColor.rgb = surfaceMaterialAmbientColor.rgb * clamp(pointlight.pointlightEmissiveColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialAmbientColor.rgb = surfaceMaterialAmbientColor.rgb * surfaceMaterialAmbientStrength;

    vec3 surfaceMaterialDiffuseColor = clamp(surfaceMaterial.materialAlbedoColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialDiffuseColor.rgb = surfaceMaterialDiffuseColor.rgb * clamp(pointlight.pointlightEmissiveColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialDiffuseColor.rgb = surfaceMaterialDiffuseColor.rgb * surfaceMaterialDiffuseStrength;

    vec3 surfaceMaterialSpecularColor = clamp(surfaceMaterial.materialAlbedoColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialSpecularColor.rgb = surfaceMaterialSpecularColor.rgb * clamp(pointlight.pointlightEmissiveColor.rgb, vec3(0.0f, 0.0f, 0.0f).rgb, vec3(1.0f, 1.0f, 1.0f).rgb).rgb;
    surfaceMaterialSpecularColor.rgb = surfaceMaterialSpecularColor.rgb * surfaceMaterialSpecularStrength;
    
    vec3 surfaceMaterialCompleteColor = vec3(0.0f, 0.0f, 0.0f).rgb;
    surfaceMaterialCompleteColor.rgb = surfaceMaterialCompleteColor.rgb + surfaceMaterialAmbientColor.rgb;
    surfaceMaterialCompleteColor.rgb = surfaceMaterialCompleteColor.rgb + surfaceMaterialDiffuseColor.rgb;
    surfaceMaterialCompleteColor.rgb = surfaceMaterialCompleteColor.rgb + surfaceMaterialSpecularColor.rgb;

    fragmentOutputColor.rgb = fragmentOutputColor.rgb + surfaceMaterialCompleteColor.rgb;
}

void setFragmentBackgroundColor(inout vec3 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec3 fragmentTileEvenColor, const in vec3 fragmentTileOddColor, const in float fragmentTileDimension, const in vec3 fragmentLineColor, const in float fragmentLineDimension)
{
    vec2 fragmentOffsetCoordinates = (iResolution.x < iResolution.y ? vec2(1.0f, 0.0f).xy : iResolution.x > iResolution.y ? vec2(0.0f, 1.0f).xy : vec2(0.0f, 0.0f).xy).xy;

    vec2 fragmentTileCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentTileCoordinates.xy = fragmentTileCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentTileCoordinates.xy = floor(fragmentTileCoordinates.xy / vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;

    float fragmentTileChecker = step(fragmentTileDimension, mod(fragmentTileCoordinates.x + fragmentTileCoordinates.y, 2.0f));

    fragmentOutputColor.rgb = mix(fragmentTileEvenColor.rgb, fragmentTileOddColor.rgb, fragmentTileChecker).rgb;

    vec2 fragmentLineCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentLineCoordinates.xy = fragmentLineCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentLineCoordinates.xy = mod(fragmentLineCoordinates.xy, vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;
    fragmentLineCoordinates.xy = min(fragmentLineCoordinates.xy, vec2(fragmentTileDimension, fragmentTileDimension).xy - fragmentLineCoordinates.xy).xy;

    float fragmentLineChecker = step(min(fragmentLineCoordinates.x, fragmentLineCoordinates.y), fragmentLineDimension);

    fragmentOutputColor.rgb = mix(fragmentOutputColor.rgb, fragmentLineColor.rgb, fragmentLineChecker).rgb;
}

void setVignetteImageProcessing(inout vec3 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec3 vignetteMaskColor, const in float vignetteTransformScale, const in float vignetteMaskRoundness, const in float vignetteMaskSmoothness)
{
    vec2 fragmentPixelCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / iResolution.xy;

    vec2 vignetteTransformPosition = abs(fragmentPixelCoordinates.xy).xy - vec2(vignetteTransformScale * (1.0f - vignetteMaskRoundness), vignetteTransformScale * (1.0f - vignetteMaskRoundness)).xy;

    float vignetteMaskDistance = min(max(vignetteTransformPosition.x, vignetteTransformPosition.y), 0.0f) + length(max(vignetteTransformPosition.xy, vec2(0.0f, 0.0f).xy).xy);
    vignetteMaskDistance = smoothstep(0.0f, vignetteMaskSmoothness, vignetteMaskDistance - vignetteTransformScale * vignetteMaskRoundness);

    fragmentOutputColor.rgb = mix(fragmentOutputColor.rgb, vignetteMaskColor.rgb, vignetteMaskDistance).rgb;
}

void setGammaCorrectionImageProcessing(inout vec3 fragmentOutputColor)
{
    const vec3 GammaCorrectionColor = vec3(1.0f / 2.2f, 1.0f / 2.2f, 1.0f / 2.2f).rgb;

    fragmentOutputColor.rgb = pow(fragmentOutputColor.rgb, GammaCorrectionColor.rgb).rgb;
}

void mainImage(out vec4 fragmentOutputColor, in vec2 fragmentInputCoordinates)
{
    fragmentOutputColor.rgba = vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba;
    
    vec3 cameraTransformPosition = vec3(0.0f, 0.0f, 0.0f).xyz;
    {
        float cameraTransformDepthDistance = 50.0f;
        
        vec3 cameraTransformOffsetPoint = cameraTransformDepthDistance * vec3(cos(0.5f) * cos(iTime), sin(0.5f), cos(0.5f) * sin(iTime));
        
        cameraTransformPosition.xyz = CameraTransformLookAtPoint.xyz + cameraTransformOffsetPoint.xyz;
    }
    
    vec3 cameraTransformDirection = vec3(0.0f, 0.0f, 0.0f).xyz;
    {
        mat3 cameraTransformOrientation = getTransformLookAtOrientation(cameraTransformPosition.xyz, CameraTransformLookAtPoint.xyz);
        
        vec2 cameraViewportCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
        
        const float CameraDisplayMinimumFieldOfView = 10.0f;
        const float CameraDisplayMaximumFieldOfView = 170.0f;
        float cameraDisplayFieldOfView = clamp(60.0f, CameraDisplayMinimumFieldOfView, CameraDisplayMaximumFieldOfView);
        
        float cameraDisplayFocalLength = 1.0f / tan(0.5f * radians(cameraDisplayFieldOfView));
        
        cameraTransformDirection.xyz = cameraTransformOrientation * normalize(vec3(cameraViewportCoordinates.x, cameraViewportCoordinates.y, -cameraDisplayFocalLength).xyz).xyz;
    }
    
    surface raymarchSurface = getRaymarchSurface(cameraTransformPosition.xyz, cameraTransformDirection.xyz);
    
    const float CameraDisplayNearClippingPlane = 0.0001f;
    const float CameraDisplayFarClippingPlane = 500.0f;
    
    if (raymarchSurface.surfaceDistance < CameraDisplayNearClippingPlane || raymarchSurface.surfaceDistance > CameraDisplayFarClippingPlane)
    {
        setFragmentBackgroundColor(fragmentOutputColor.rgb, fragmentInputCoordinates.xy, vec3(1.0f / 20.0f, 1.0f / 20.0f, 1.0f / 20.0f).rgb, vec3(1.0f / 10.0f, 1.0f / 10.0f, 1.0f / 10.0f).rgb, 0.25f, vec3(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f).rgb, 0.005f);
    }
    else
    {
        vec3 surfaceTransformPosition = cameraTransformPosition.xyz + raymarchSurface.surfaceDistance * cameraTransformDirection.xyz;
        
        vec3 surfaceTransformDirection = vec3(0.0f, 0.0f, 0.0f).xyz;
        surfaceTransformDirection.x = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0001f, 0.0f, 0.0f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0001f, 0.0f, 0.0f).xyz).surfaceDistance;
        surfaceTransformDirection.y = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0f, 0.0001f, 0.0f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0f, 0.0001f, 0.0f).xyz).surfaceDistance;
        surfaceTransformDirection.z = getSceneSurface(surfaceTransformPosition.xyz + vec3(0.0f, 0.0f, 0.0001f).xyz).surfaceDistance - getSceneSurface(surfaceTransformPosition.xyz - vec3(0.0f, 0.0f, 0.0001f).xyz).surfaceDistance;
        surfaceTransformDirection.xyz = normalize(surfaceTransformDirection.xyz).xyz;
        
        pointlight pointlight01 = pointlight(vec3(-50.0f, 50.0f, -50.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 100.0f);
        
        pointlight pointlight02 = pointlight(vec3(-50.0f, 50.0f, 50.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 100.0f);
        
        pointlight pointlight03 = pointlight(vec3(50.0f, 50.0f, -50.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 100.0f);
        
        pointlight pointlight04 = pointlight(vec3(50.0f, 50.0f, 50.0f).xyz, vec3(1.0f, 1.0f, 1.0f).rgb, 1.0f, 100.0f);
        
        setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight01, raymarchSurface.surfaceMaterial);
        
        setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight02, raymarchSurface.surfaceMaterial);
        
        setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight03, raymarchSurface.surfaceMaterial);
        
        setFragmentForegroundColor(fragmentOutputColor.rgb, cameraTransformPosition.xyz, cameraTransformDirection.xyz, surfaceTransformPosition.xyz, surfaceTransformDirection.xyz, pointlight04, raymarchSurface.surfaceMaterial);
    }
    
    setVignetteImageProcessing(fragmentOutputColor.rgb, fragmentInputCoordinates.xy, vec3(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f).rgb, 0.5f, 0.5f, 0.5f);
    
    setGammaCorrectionImageProcessing(fragmentOutputColor.rgb);
}
