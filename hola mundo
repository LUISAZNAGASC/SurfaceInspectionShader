struct light { vec3 lightTransformPosition; float lightSoftnessFactor; float lightHardnessFactor; vec4 lightEmissiveColor; };

struct material { float materialAmbientFactor; vec4 materialAmbientColor; float materialDiffuseFactor; vec4 materialDiffuseColor; float materialSpecularFactor; vec4 materialSpecularColor; float materialSpecularAlpha; float materialFresnelFactor; vec4 materialFresnelColor; float materialFresnelAlpha; };

struct surface { float surfaceSignedDistance; material surfaceMaterial; };

const float CameraNearClippingPlane = 0.0001f;
const float CameraFarClippingPlane = 500.0f;
const vec3 CameraLookAtPosition = vec3(0.0f, 0.0f, 50.0f).xyz;

mat3 getTransformAllInOneOrientation(const in vec3 transformTargetRotation)
{
    vec3 transformSineRotation = sin(radians(transformTargetRotation.xyz).xyz).xyz;
    vec3 transformCosineRotation = cos(radians(transformTargetRotation.xyz).xyz).xyz;
    
    mat3 transformPitchOrientation;
    transformPitchOrientation[0u].xyz = vec3(1.0f, 0.0f, 0.0f).xyz;
    transformPitchOrientation[1u].xyz = vec3(0.0f, transformCosineRotation.x, -transformSineRotation.x).xyz;
    transformPitchOrientation[2u].xyz = vec3(0.0f, transformSineRotation.x, transformCosineRotation.x).xyz;
    
    mat3 transformYawOrientation;
    transformYawOrientation[0u].xyz = vec3(transformCosineRotation.y, 0.0f, transformSineRotation.y).xyz;
    transformYawOrientation[1u].xyz = vec3(0.0f, 1.0f, 0.0f).xyz;
    transformYawOrientation[2u].xyz = vec3(-transformSineRotation.y, 0.0f, transformCosineRotation.y).xyz;
    
    mat3 transformRollOrientation;
    transformRollOrientation[0u].xyz = vec3(transformCosineRotation.z, -transformSineRotation.z, 0.0f).xyz;
    transformRollOrientation[1u].xyz = vec3(transformSineRotation.z, transformCosineRotation.z, 0.0f).xyz;
    transformRollOrientation[2u].xyz = vec3(0.0f, 0.0f, 1.0f).xyz;
    
    mat3 transformAllInOneOrientation = transformRollOrientation * transformYawOrientation * transformPitchOrientation;
    
    return transformAllInOneOrientation;
}

mat3 getTransformLookAtOrientation(const in vec3 transformOriginPosition, const in vec3 transformTargetPosition)
{
    vec3 transformForwardDirection = normalize(transformTargetPosition.xyz - transformOriginPosition.xyz).xyz;
    vec3 transformRightwardDirection = normalize(cross(vec3(0.0f, 1.0f, 0.0f).xyz, transformForwardDirection.xyz).xyz).xyz;
    vec3 transformUpwardDirection = normalize(cross(transformForwardDirection.xyz, transformRightwardDirection.xyz).xyz).xyz;
    
    mat3 transformLookAtOrientation = mat3(-transformRightwardDirection.xyz, transformUpwardDirection.xyz, -transformForwardDirection.xyz);
    
    return transformLookAtOrientation;
}

void setFragmentBackgroundColor(inout vec4 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec4 fragmentTileEvenColor, const in vec4 fragmentTileOddColor, const in float fragmentTileDimension, const in vec4 fragmentLineColor, const in float fragmentLineDimension)
{
    vec2 fragmentOffsetCoordinates = (iResolution.x < iResolution.y ? vec2(1.0f, 0.0f).xy : iResolution.x > iResolution.y ? vec2(0.0f, 1.0f).xy : vec2(0.0f, 0.0f).xy).xy;
    
    vec2 fragmentTileCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentTileCoordinates.xy = fragmentTileCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentTileCoordinates.xy = floor(fragmentTileCoordinates.xy / vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;
    
    float fragmentTileChecker = step(fragmentTileDimension, mod(fragmentTileCoordinates.x + fragmentTileCoordinates.y, 2.0f));
    
    fragmentOutputColor.rgba = mix(fragmentTileEvenColor.rgba, fragmentTileOddColor.rgba, fragmentTileChecker).rgba;
    
    vec2 fragmentLineCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
    fragmentLineCoordinates.xy = fragmentLineCoordinates.xy + vec2(fragmentTileDimension, fragmentTileDimension).xy * fragmentOffsetCoordinates.xy;
    fragmentLineCoordinates.xy = mod(fragmentLineCoordinates.xy, vec2(fragmentTileDimension, fragmentTileDimension).xy).xy;
    fragmentLineCoordinates.xy = min(fragmentLineCoordinates.xy, vec2(fragmentTileDimension, fragmentTileDimension).xy - fragmentLineCoordinates.xy).xy;
    
    float fragmentLineChecker = step(min(fragmentLineCoordinates.x, fragmentLineCoordinates.y), fragmentLineDimension);
    
    fragmentOutputColor.rgba = mix(fragmentOutputColor.rgba, fragmentLineColor.rgba, fragmentLineChecker).rgba;
}

surface getMixedSurface(const in surface firstSurface, const in surface secondSurface, const in float mixedSurfaceSmoothness)
{
    float mixedSurfaceSignedDistance;
    {
        float mixedSurfaceInterpolation = clamp(0.5f + 0.5f * (firstSurface.surfaceSignedDistance - secondSurface.surfaceSignedDistance) / mixedSurfaceSmoothness, 0.0f, 1.0f);
        
        mixedSurfaceSignedDistance = mix(firstSurface.surfaceSignedDistance, secondSurface.surfaceSignedDistance, mixedSurfaceInterpolation) - mixedSurfaceSmoothness * mixedSurfaceInterpolation * (1.0f - mixedSurfaceInterpolation);
    }
    
    material mixedSurfaceMaterial;
    {
        float mixedSurfaceInterpolation = clamp((firstSurface.surfaceSignedDistance - mixedSurfaceSignedDistance) / (firstSurface.surfaceSignedDistance + secondSurface.surfaceSignedDistance - 2.0f * mixedSurfaceSignedDistance), 0.0f, 1.0f);
        
        mixedSurfaceMaterial.materialAmbientFactor = mix(firstSurface.surfaceMaterial.materialAmbientFactor, secondSurface.surfaceMaterial.materialAmbientFactor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialAmbientColor = mix(firstSurface.surfaceMaterial.materialAmbientColor, secondSurface.surfaceMaterial.materialAmbientColor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialDiffuseFactor = mix(firstSurface.surfaceMaterial.materialDiffuseFactor, secondSurface.surfaceMaterial.materialDiffuseFactor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialDiffuseColor = mix(firstSurface.surfaceMaterial.materialDiffuseColor, secondSurface.surfaceMaterial.materialDiffuseColor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialSpecularFactor = mix(firstSurface.surfaceMaterial.materialSpecularFactor, secondSurface.surfaceMaterial.materialSpecularFactor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialSpecularColor = mix(firstSurface.surfaceMaterial.materialSpecularColor, secondSurface.surfaceMaterial.materialSpecularColor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialSpecularAlpha = mix(firstSurface.surfaceMaterial.materialSpecularAlpha, secondSurface.surfaceMaterial.materialSpecularAlpha, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialFresnelFactor = mix(firstSurface.surfaceMaterial.materialFresnelFactor, secondSurface.surfaceMaterial.materialFresnelFactor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialFresnelColor = mix(firstSurface.surfaceMaterial.materialFresnelColor, secondSurface.surfaceMaterial.materialFresnelColor, mixedSurfaceInterpolation);
        mixedSurfaceMaterial.materialFresnelAlpha = mix(firstSurface.surfaceMaterial.materialFresnelAlpha, secondSurface.surfaceMaterial.materialFresnelAlpha, mixedSurfaceInterpolation);
    }
    
    surface mixedSurface = surface(mixedSurfaceSignedDistance, mixedSurfaceMaterial);
    
    return mixedSurface;
}

surface getSphereSurface(const in vec3 sceneTransformPosition, const in vec3 sphereTransformPosition, const in vec3 sphereTransformRotation, const in float sphereTransformRadius, const in material sphereSurfaceMaterial)
{
    float sphereSurfaceSignedDistance;
    {
        mat3 sphereTransformOrientation = getTransformAllInOneOrientation(sphereTransformRotation.xyz);
        
        vec3 sphereTransformLocalPosition = sphereTransformOrientation * (sceneTransformPosition.xyz - sphereTransformPosition.xyz).xyz;
        
        sphereSurfaceSignedDistance = length(sphereTransformLocalPosition.xyz) - abs(sphereTransformRadius);
    }
    
    surface sphereSurface = surface(sphereSurfaceSignedDistance, sphereSurfaceMaterial);
    
    return sphereSurface;
}

surface getPrototypeSurface(const in vec3 sceneTransformPosition, const in vec3 prototypeTransformPosition, const in vec3 prototypeTransformRotation, const in float prototypeTransformScale, const in material prototypeSurfaceMaterial)
{
    vec3 prototypeRaypointPosition;
    {
        mat3 prototypeTransformOrientation = getTransformAllInOneOrientation(prototypeTransformRotation.xyz);
        
        prototypeRaypointPosition.xyz = prototypeTransformOrientation * (sceneTransformPosition.xyz - prototypeTransformPosition.xyz).xyz;
    }
    
    surface upperCenterSurface;
    {
        vec3 upperCenterTransformPosition = prototypeTransformScale * vec3(0.0f, 0.5f * sqrt(3.0f) * 2.0f / 3.0f, 0.0f).xyz;
        vec3 upperCenterTransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
        float upperCenterTransformRadius = 2.0f / 3.0f * prototypeTransformScale;
        
        material upperCenterSurfaceMaterial = prototypeSurfaceMaterial;
        
        upperCenterSurface = getSphereSurface(prototypeRaypointPosition.xyz, upperCenterTransformPosition.xyz, upperCenterTransformRotation.xyz, upperCenterTransformRadius, upperCenterSurfaceMaterial);
    }
    
    surface lowerLeftSurface;
    {
        vec3 lowerLeftTransformPosition = prototypeTransformScale * vec3(-0.5f, -0.5f * sqrt(3.0f) / 3.0f, 0.0f).xyz;
        vec3 lowerLeftTransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
        float lowerLeftTransformRadius = 2.0f / 3.0f * prototypeTransformScale;
        
        material lowerLeftSurfaceMaterial = prototypeSurfaceMaterial;
        
        lowerLeftSurface = getSphereSurface(prototypeRaypointPosition.xyz, lowerLeftTransformPosition.xyz, lowerLeftTransformRotation.xyz, lowerLeftTransformRadius, lowerLeftSurfaceMaterial);
    }
    
    surface lowerRightSurface;
    {
        vec3 lowerRightTransformPosition = prototypeTransformScale * vec3(0.5f, -0.5f * sqrt(3.0f) / 3.0f, 0.0f).xyz;
        vec3 lowerRightTransformRotation = vec3(0.0f, 0.0f, 0.0f).xyz;
        float lowerRightTransformRadius = 2.0f / 3.0f * prototypeTransformScale;
        
        material lowerRightSurfaceMaterial = prototypeSurfaceMaterial;
        
        lowerRightSurface = getSphereSurface(prototypeRaypointPosition.xyz, lowerRightTransformPosition.xyz, lowerRightTransformRotation.xyz, lowerRightTransformRadius, lowerRightSurfaceMaterial);
    }
    
    surface prototypeSurface;
    prototypeSurface = getMixedSurface(lowerLeftSurface, lowerRightSurface, 1.0f / 3.0f * prototypeTransformScale);
    prototypeSurface = getMixedSurface(prototypeSurface, upperCenterSurface, 1.0f / 3.0f * prototypeTransformScale);
    
    return prototypeSurface;
}

surface getSceneSurface(const in vec3 sampleTransformPosition)
{
    surface prototypeSurface;
    {
        vec3 prototypeTransformPosition = vec3(10.0f * sin(1.25f * iTime), 5.0f * cos(2.5f * iTime), 10.0f * sin(1.25f * iTime)).xyz + CameraLookAtPosition.xyz;
        vec3 prototypeTransformRotation = vec3(90.0f * iTime, 45.0f * iTime, 90.0f * iTime).xyz;
        float prototypeTransformScale = 10.0f;
        
        material prototypeSurfaceMaterial = material(
        1.0f, vec4(0.0f, 0.0f, 0.25f, 1.0f).rgba,
        1.0f, vec4(0.0f, 0.0f, 0.5f, 1.0f).rgba,
        1.0f, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba, 128.0,
        1.0f, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba, 5.0f);
        
        prototypeSurface = getPrototypeSurface(sampleTransformPosition.xyz, prototypeTransformPosition.xyz, prototypeTransformRotation.xyz, prototypeTransformScale, prototypeSurfaceMaterial);
    }
    
    surface sceneSurface;
    sceneSurface = prototypeSurface;
    
    return sceneSurface;
}

surface getRaymarchSurface(const in vec3 sampleTransformPosition, const in vec3 sampleTransformDirection)
{
    float raymarchSurfaceSignedDistance = -CameraNearClippingPlane;
    
    surface raymarchSurface;
    raymarchSurface.surfaceSignedDistance = raymarchSurfaceSignedDistance;
    
    const float RaymarchSurfaceIterator = 750.0f;
    
    for (float raymarchSurfaceCounter = 0.0f; raymarchSurfaceCounter < RaymarchSurfaceIterator; raymarchSurfaceCounter++)
    {
        vec3 raymarchTransformPosition = sampleTransformPosition.xyz + raymarchSurfaceSignedDistance * sampleTransformDirection.xyz;
        
        raymarchSurface = getSceneSurface(raymarchTransformPosition.xyz);
        
        if (raymarchSurface.surfaceSignedDistance < CameraNearClippingPlane || raymarchSurfaceSignedDistance > CameraFarClippingPlane)
        {
            break;
        }
        
        raymarchSurfaceSignedDistance = raymarchSurfaceSignedDistance + raymarchSurface.surfaceSignedDistance;
    }
    
    raymarchSurface.surfaceSignedDistance = raymarchSurfaceSignedDistance;
    
    return raymarchSurface;
}

void setFragmentForegroundColor(inout vec4 fragmentOutputColor, vec3 cameraTransformPosition, const in vec3 cameraTransformDirection, const in vec3 normalTransformPosition, const in vec3 normalTransformDirection, const in light sceneLight, const in material raymarchMaterial)
{
    vec3 observerTransformDirection = normalize(cameraTransformPosition.xyz - normalTransformPosition.xyz).xyz;
    
    vec3 lightTransformDirection = normalize(sceneLight.lightTransformPosition.xyz - normalTransformPosition.xyz).xyz;
    
    vec3 reflectionTransformDirection = normalize(reflect(-lightTransformDirection.xyz, normalTransformDirection.xyz).xyz).xyz;
    
    float raymarchMaterialAmbientStrength = clamp(raymarchMaterial.materialAmbientFactor, 0.0f, 1.0f);
    raymarchMaterialAmbientStrength = raymarchMaterialAmbientStrength * clamp(sceneLight.lightSoftnessFactor, 0.0f, 1.0f);
    
    float raymarchMaterialDiffuseStrength = clamp(dot(lightTransformDirection.xyz, normalTransformDirection.xyz), 0.0f, 1.0f);
    raymarchMaterialDiffuseStrength = raymarchMaterialDiffuseStrength * clamp(raymarchMaterial.materialDiffuseFactor, 0.0f, 1.0f);
    raymarchMaterialDiffuseStrength = raymarchMaterialDiffuseStrength * clamp(sceneLight.lightHardnessFactor, 0.0f, 1.0f);
    
    const float RaymarchMaterialSpecularLowerAlpha = 0.0f;
    const float RaymarchMaterialSpecularUpperAlpha = 128.0f;
    float raymarchMaterialSpecularStrength = clamp(dot(reflectionTransformDirection.xyz, observerTransformDirection.xyz), 0.0f, 1.0f);
    raymarchMaterialSpecularStrength = pow(raymarchMaterialSpecularStrength, clamp(raymarchMaterial.materialSpecularAlpha, RaymarchMaterialSpecularLowerAlpha, RaymarchMaterialSpecularUpperAlpha));
    raymarchMaterialSpecularStrength = raymarchMaterialSpecularStrength * clamp(raymarchMaterial.materialSpecularFactor, 0.0f, 1.0f);
    raymarchMaterialSpecularStrength = raymarchMaterialSpecularStrength * clamp(sceneLight.lightHardnessFactor, 0.0f, 1.0f);
    
    const float RaymarchMaterialFresnelLowerAlpha = 0.0f;
    const float RaymarchMaterialFresnelUpperAlpha = 10.0f;
    float raymarchMaterialFresnelStrength = clamp(1.0f - dot(normalTransformDirection.xyz, observerTransformDirection.xyz), 0.0f, 1.0f);
    raymarchMaterialFresnelStrength = pow(raymarchMaterialFresnelStrength, clamp(raymarchMaterial.materialFresnelAlpha, RaymarchMaterialFresnelLowerAlpha, RaymarchMaterialFresnelUpperAlpha));
    raymarchMaterialFresnelStrength = raymarchMaterialFresnelStrength * clamp(raymarchMaterial.materialFresnelFactor, 0.0f, 1.0f);
    raymarchMaterialFresnelStrength = raymarchMaterialFresnelStrength * clamp(sceneLight.lightHardnessFactor, 0.0f, 1.0f);
    
    vec4 raymarchMaterialAmbientColor = clamp(raymarchMaterial.materialAmbientColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    raymarchMaterialAmbientColor.rgba = raymarchMaterialAmbientColor.rgba * raymarchMaterialAmbientStrength;
    raymarchMaterialAmbientColor.rgba = raymarchMaterialAmbientColor.rgba * clamp(sceneLight.lightEmissiveColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    
    vec4 raymarchMaterialDiffuseColor = clamp(raymarchMaterial.materialDiffuseColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    raymarchMaterialDiffuseColor.rgba = raymarchMaterialDiffuseColor.rgba * raymarchMaterialDiffuseStrength;
    raymarchMaterialDiffuseColor.rgba = raymarchMaterialDiffuseColor.rgba * clamp(sceneLight.lightEmissiveColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    
    vec4 raymarchMaterialSpecularColor = clamp(raymarchMaterial.materialSpecularColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    raymarchMaterialSpecularColor.rgba = raymarchMaterialSpecularColor.rgba * raymarchMaterialSpecularStrength;
    raymarchMaterialSpecularColor.rgba = raymarchMaterialSpecularColor.rgba * clamp(sceneLight.lightEmissiveColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    
    vec4 raymarchMaterialFresnelColor = clamp(raymarchMaterial.materialFresnelColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    raymarchMaterialFresnelColor.rgba = raymarchMaterialFresnelColor.rgba * raymarchMaterialFresnelStrength;
    raymarchMaterialFresnelColor.rgba = raymarchMaterialFresnelColor.rgba * clamp(sceneLight.lightEmissiveColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    
    vec4 raymarchMaterialResultColor = vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba;
    raymarchMaterialResultColor.rgba = raymarchMaterialResultColor.rgba + raymarchMaterialAmbientColor.rgba;
    raymarchMaterialResultColor.rgba = raymarchMaterialResultColor.rgba + raymarchMaterialDiffuseColor.rgba;
    raymarchMaterialResultColor.rgba = raymarchMaterialResultColor.rgba + raymarchMaterialSpecularColor.rgba;
    raymarchMaterialResultColor.rgba = raymarchMaterialResultColor.rgba + raymarchMaterialFresnelColor.rgba;
    raymarchMaterialResultColor.rgba = clamp(raymarchMaterialResultColor.rgba, vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba).rgba;
    
    fragmentOutputColor.rgba =  fragmentOutputColor.rgba + raymarchMaterialResultColor.rgba;
}

void setVignetteImageProcessing(inout vec4 fragmentOutputColor, const in vec2 fragmentInputCoordinates, const in vec4 vignetteColor, const in float vignetteDimension, const in float vignetteRoundness, const in float vignetteSmoothness)
{
    vec2 fragmentPixelCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / iResolution.xy;
    
    vec2 vignettePosition = abs(fragmentPixelCoordinates.xy).xy - vec2(vignetteDimension * (1.0f - vignetteRoundness), vignetteDimension * (1.0f - vignetteRoundness)).xy;
    
    float vignetteSignedDistance = min(max(vignettePosition.x, vignettePosition.y), 0.0f) + length(max(vignettePosition.xy, vec2(0.0f ,0.0f).xy).xy);
    vignetteSignedDistance = 1.0f - smoothstep(0.0f, vignetteSmoothness, vignetteSignedDistance - vignetteDimension * vignetteRoundness);
    
    fragmentOutputColor.rgba = mix(fragmentOutputColor.rgba, vignetteColor.rgba, 1.0f - vignetteSignedDistance).rgba;
}

void setGammaCorrectionImageProcessing(inout vec4 fragmentOutputColor)
{
    const vec4 GammaCorrectionColor = vec4(1.0f / 2.2f, 1.0f / 2.2f, 1.0f / 2.2f, 1.0f).rgba;
    
    fragmentOutputColor.rgba = pow(fragmentOutputColor.rgba, GammaCorrectionColor.rgba).rgba;
}

void mainImage(out vec4 fragmentOutputColor, in vec2 fragmentInputCoordinates)
{
    vec3 cameraTransformPosition = vec3(25.0f, 25.0f, 25.0f).xyz;
    vec3 cameraTransformDirection;
    {
        mat3 cameraTransformOrientation = getTransformLookAtOrientation(cameraTransformPosition.xyz, CameraLookAtPosition.xyz);
        
        vec2 cameraViewportCoordinates = (2.0f * fragmentInputCoordinates.xy - iResolution.xy).xy / min(iResolution.x, iResolution.y);
        
        const float CameraMinimumFieldOfView = 10.0f;
        const float CameraMaximumFieldOfView = 170.0f;
        float cameraFocalLength = 1.0f / tan(0.5f * radians(clamp(30.0f, CameraMinimumFieldOfView, CameraMaximumFieldOfView)));
        
        cameraTransformDirection.xyz = cameraTransformOrientation * normalize(vec3(cameraViewportCoordinates.xy, -cameraFocalLength).xyz).xyz;
    }
    
    surface raymarchSurface = getRaymarchSurface(cameraTransformPosition.xyz, cameraTransformDirection.xyz);
    
    fragmentOutputColor.rgba = vec4(0.0f, 0.0f, 0.0f, 1.0f).rgba;
    
    if (raymarchSurface.surfaceSignedDistance >= CameraNearClippingPlane && raymarchSurface.surfaceSignedDistance <= CameraFarClippingPlane)
    {
        vec3 normalTransformPosition = cameraTransformPosition.xyz + raymarchSurface.surfaceSignedDistance * cameraTransformDirection.xyz;
        vec3 normalTransformDirection;
        normalTransformDirection.x = getSceneSurface(normalTransformPosition.xyz + vec2(0.0f, 0.0001f).yxx).surfaceSignedDistance - getSceneSurface(normalTransformPosition.xyz - vec2(0.0f, 0.0001f).yxx).surfaceSignedDistance;
        normalTransformDirection.y = getSceneSurface(normalTransformPosition.xyz + vec2(0.0f, 0.0001f).xyx).surfaceSignedDistance - getSceneSurface(normalTransformPosition.xyz - vec2(0.0f, 0.0001f).xyx).surfaceSignedDistance;
        normalTransformDirection.z = getSceneSurface(normalTransformPosition.xyz + vec2(0.0f, 0.0001f).xxy).surfaceSignedDistance - getSceneSurface(normalTransformPosition.xyz - vec2(0.0f, 0.0001f).xxy).surfaceSignedDistance;
        normalTransformDirection.xyz = normalize(normalTransformDirection.xyz).xyz;
        
        light sceneLight = light(vec3(-25.0f, 50.0f, .0f).xyz, 0.15f, 0.75f, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba);
        
        setFragmentForegroundColor(fragmentOutputColor.rgba, cameraTransformPosition.xyz, cameraTransformDirection.xyz, normalTransformPosition.xyz, normalTransformDirection.xyz, sceneLight, raymarchSurface.surfaceMaterial);
        
        light sceneLight1 = light(vec3(25.0f, .0f, 25.0f).xyz, 0.05f, 0.5f, vec4(1.0f, 1.0f, 1.0f, 1.0f).rgba);
        
     //   setFragmentForegroundColor(fragmentOutputColor.rgba, cameraTransformPosition.xyz, cameraTransformDirection.xyz, normalTransformPosition.xyz, normalTransformDirection.xyz, sceneLight1, raymarchSurface.surfaceMaterial);
    }
    else
    {
        setFragmentBackgroundColor(fragmentOutputColor.rgba, fragmentInputCoordinates.xy, vec4(1.0f / 20.0f, 1.0f / 20.0f, 1.0f / 20.0f, 1.0f).rgba, vec4(1.0f / 10.0f, 1.0f / 10.0f, 1.0f / 10.0f, 1.0f).rgba, 0.25f, vec4(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f, 1.0f).rgba, 0.0075f);
    }
    
    setVignetteImageProcessing(fragmentOutputColor.rgba, fragmentInputCoordinates.xy, vec4(1.0f / 100.0f, 1.0f / 100.0f, 1.0f / 100.0f, 1.0f).rgba, 0.5f, 0.5f, 0.5f);
    setGammaCorrectionImageProcessing(fragmentOutputColor.rgba);
}
